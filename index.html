<!DOCTYPE html>
<html>
<head>
    <title>Bouncing Squares Game</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
            padding: 20px;
        }
        #container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        #canvas-wrapper {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .health-bars {
            display: flex;
            gap: 20px;
            margin-bottom: 10px;
        }
        .health-bar {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        .health-bar-container {
            width: 180px;
            height: 20px;
            border: 2px solid #333;
            background-color: #ddd;
            display: flex;
            border-radius: 4px;
            overflow: hidden;
        }
        .health-segment {
            flex: 1;
            height: 100%;
            border-right: 1px solid #333;
            transition: background-color 0.3s ease;
        }
        .health-segment:last-child {
            border-right: none;
        }
        .health-bar-label {
            font-size: 12px;
            font-weight: bold;
            color: #333;
        }
        canvas {
            border: 2px solid #333;
            background-color: white;
        }
        canvas:fullscreen {
            object-fit: contain;
        }
        #healthBarCanvas {
            border: 2px solid #666;
            margin-top: 20px;
            background-color: #FCFEFE;
        }
        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        button {
            padding: 8px 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .restore-btn {
            background-color: #9b59b6;
        }
        .restore-btn:hover {
            background-color: #8e44ad;
        }
        .fullscreen-btn {
            background-color: #3498db;
        }
        .fullscreen-btn:hover {
            background-color: #2980b9;
        }
        .download-btn {
            background-color: #e67e22;
        }
        .download-btn:hover {
            background-color: #d35400;
        }
        .recording-btn {
            background-color: #e74c3c;
        }
        .recording-btn:hover {
            background-color: #c0392b;
        }
        .color-picker {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }
        .health-color-controls {
            display: flex;
            gap: 20px;
            margin-top: 10px;
            justify-content: center;
        }
        .health-color-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        .background-color-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
            padding: 10px;
            background-color: #f9f9f9;
            border-radius: 8px;
            border: 1px solid #ddd;
        }
        label {
            font-weight: bold;
        }
        .color-input {
            padding: 4px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 80px;
            text-align: center;
        }
        .color-picker-input {
            width: 50px;
            height: 30px;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 0;
            cursor: pointer;
        }
        .frame-color-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
            padding: 10px;
            background-color: #f9f9f9;
            border-radius: 8px;
            border: 1px solid #ddd;
        }
        .game-info {
            font-size: 12px;
            color: #666;
            text-align: center;
            margin-top: 5px;
            padding: 10px;
            background-color: #e8e8e8;
            border-radius: 8px;
            border: 2px solid #ccc;
        }
        .audio-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        .health-bar-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            margin-top: 20px;
            padding: 20px;
            background-color: #f9f9f9;
            border-radius: 8px;
            border: 2px solid #ddd;
        }
        .health-bar-customization {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .video-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        .recording-indicator {
            color: #e74c3c;
            font-weight: bold;
            font-size: 14px;
        }
        .segment-customization {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 15px;
            padding: 15px;
            background-color: #fff;
            border-radius: 8px;
            border: 2px solid #ddd;
        }
        .bar-segments {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .segment-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .segment-label {
            min-width: 100px;
            font-weight: bold;
            font-size: 13px;
        }
        .bar-title {
            font-size: 16px;
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-wrapper">
            <div class="health-bars">
                <div class="health-bar">
                    <div class="health-bar-label">Blue Square</div>
                    <div class="health-bar-container" id="blueHealthBar">
                        <div class="health-segment"></div>
                        <div class="health-segment"></div>
                        <div class="health-segment"></div>
                        <div class="health-segment"></div>
                    </div>
                </div>
                <div class="health-bar">
                    <div class="health-bar-label">Red Square</div>
                    <div class="health-bar-container" id="redHealthBar">
                        <div class="health-segment"></div>
                        <div class="health-segment"></div>
                        <div class="health-segment"></div>
                        <div class="health-segment"></div>
                    </div>
                </div>
            </div>
            <canvas id="canvas" width="1080" height="720"></canvas>
        </div>
        
        <div class="game-info">
            <strong>Mobile Controls:</strong> Volume Down=Pause, Volume Up=Reset, Button=Fullscreen, 1/2/3=Speed
        </div>
        
        <div class="audio-controls">
            <button id="startAudioBtn">Start Audio Tracking</button>
            <button id="downloadAudioBtn" class="download-btn" disabled>Download Audio</button>
        </div>
        
        <div class="background-color-control">
            <label for="backgroundColorText">Canvas Background Color:</label>
            <input type="text" id="backgroundColorText" class="color-input" value="#ffffff" placeholder="#RRGGBB">
            <input type="color" id="backgroundColorPicker" class="color-picker-input" value="#ffffff">
            <button id="applyBackgroundBtn">Apply</button>
            <button id="restoreBackgroundBtn" class="restore-btn">Restore Previous</button>
        </div>
        
        <div class="frame-color-control">
            <label for="frameColorText">Collision Frame Color:</label>
            <input type="text" id="frameColorText" class="color-input" value="#00ff00" placeholder="#RRGGBB">
            <input type="color" id="frameColorPicker" class="color-picker-input" value="#00ff00">
            <button id="applyFrameBtn">Apply</button>
            <button id="resetFrameBtn">Reset Frame</button>
        </div>
        
        <div class="controls">
            <button id="resetBtn">Reset</button>
            <button id="pauseBtn">Pause</button>
            <button id="speedBtn">Speed: 1x</button>
            <button id="fullscreenBtn" class="fullscreen-btn">Fullscreen</button>
            <button id="clearTrailsBtn" class="restore-btn">Clear Trails</button>
        </div>
        <div class="health-color-controls">
            <div class="health-color-group">
                <label for="redHealthColor">Red Health Bar Color:</label>
                <input type="text" id="redHealthColor" class="color-input" value="#e74c3c" placeholder="#RRGGBB">
            </div>
            <div class="health-color-group">
                <label for="blueHealthColor">Blue Health Bar Color:</label>
                <input type="text" id="blueHealthColor" class="color-input" value="#3498db" placeholder="#RRGGBB">
            </div>
        </div>
        <div class="color-picker">
            <label for="redThornColor">Red Square Thorn Color:</label>
            <input type="text" id="redThornColor" class="color-input" value="#BEBEBE" placeholder="#RRGGBB">
        </div>
        <div class="color-picker">
            <label for="blueThornColor">Blue Square Thorn Color:</label>
            <input type="text" id="blueThornColor" class="color-input" value="#BEBEBE" placeholder="#RRGGBB">
        </div>

        <div class="health-bar-section">
            <h3>Standalone Health Bars (Downloadable)</h3>
            <canvas id="healthBarCanvas" width="2000" height="300"></canvas>
            
            <div class="segment-customization">
                <div class="bar-segments">
                    <div class="bar-title">Blue Health Bar Segments</div>
                    <div class="segment-row">
                        <span class="segment-label">Segment 1:</span>
                        <input type="text" id="blueSegment1" class="color-input" value="#3498db" placeholder="#RRGGBB">
                        <input type="color" id="blueSegment1Picker" class="color-picker-input" value="#3498db">
                    </div>
                    <div class="segment-row">
                        <span class="segment-label">Segment 2:</span>
                        <input type="text" id="blueSegment2" class="color-input" value="#3498db" placeholder="#RRGGBB">
                        <input type="color" id="blueSegment2Picker" class="color-picker-input" value="#3498db">
                    </div>
                    <div class="segment-row">
                        <span class="segment-label">Segment 3:</span>
                        <input type="text" id="blueSegment3" class="color-input" value="#3498db" placeholder="#RRGGBB">
                        <input type="color" id="blueSegment3Picker" class="color-picker-input" value="#3498db">
                    </div>
                    <div class="segment-row">
                        <span class="segment-label">Segment 4:</span>
                        <input type="text" id="blueSegment4" class="color-input" value="#3498db" placeholder="#RRGGBB">
                        <input type="color" id="blueSegment4Picker" class="color-picker-input" value="#3498db">
                    </div>
                </div>
                
                <div class="bar-segments">
                    <div class="bar-title">Red Health Bar Segments</div>
                    <div class="segment-row">
                        <span class="segment-label">Segment 1:</span>
                        <input type="text" id="redSegment1" class="color-input" value="#e74c3c" placeholder="#RRGGBB">
                        <input type="color" id="redSegment1Picker" class="color-picker-input" value="#e74c3c">
                    </div>
                    <div class="segment-row">
                        <span class="segment-label">Segment 2:</span>
                        <input type="text" id="redSegment2" class="color-input" value="#e74c3c" placeholder="#RRGGBB">
                        <input type="color" id="redSegment2Picker" class="color-picker-input" value="#e74c3c">
                    </div>
                    <div class="segment-row">
                        <span class="segment-label">Segment 3:</span>
                        <input type="text" id="redSegment3" class="color-input" value="#e74c3c" placeholder="#RRGGBB">
                        <input type="color" id="redSegment3Picker" class="color-picker-input" value="#e74c3c">
                    </div>
                    <div class="segment-row">
                        <span class="segment-label">Segment 4:</span>
                        <input type="text" id="redSegment4" class="color-input" value="#e74c3c" placeholder="#RRGGBB">
                        <input type="color" id="redSegment4Picker" class="color-picker-input" value="#e74c3c">
                    </div>
                </div>
                
                <div class="health-bar-customization">
                    <div class="health-color-group">
                        <label for="standaloneBorderColor">Border Color:</label>
                        <input type="text" id="standaloneBorderColor" class="color-input" value="#333333" placeholder="#RRGGBB">
                        <input type="color" id="standaloneBorderPicker" class="color-picker-input" value="#333333">
                    </div>
                    <div class="health-color-group">
                        <label for="standaloneEmptyColor">Empty Segment Color:</label>
                        <input type="text" id="standaloneEmptyColor" class="color-input" value="#dddddd" placeholder="#RRGGBB">
                        <input type="color" id="standaloneEmptyPicker" class="color-picker-input" value="#dddddd">
                    </div>
                </div>
            </div>
            
            <div class="video-controls">
                <button id="startVideoBtn" class="recording-btn">Start Recording</button>
                <button id="stopVideoBtn" class="recording-btn" disabled>Stop Recording</button>
                <button id="downloadVideoBtn" class="download-btn" disabled>Download Video</button>
                <button id="downloadHealthBarsBtn" class="download-btn">Download Image (PNG)</button>
            </div>
            <div id="recordingStatus"></div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        const healthBarCanvas = document.getElementById('healthBarCanvas');
        const healthBarCtx = healthBarCanvas.getContext('2d');

        const TRAIL_LIFETIME = 700; // in milliseconds
        const TRAIL_SPAWN_RATE = 50; // in milliseconds
        
        // Trail configuration for easy size control
        const TRAIL_CONFIG = {
            normal: {
                minSize: 4,
                maxSize: 12,
                sizeDecay: 0.995
            },
            speed: {
                minSize: 6,
                maxSize: 18,
                sizeDecay: 0.990
            }
        };
        
        const resetBtn = document.getElementById('resetBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const speedBtn = document.getElementById('speedBtn');
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const clearTrailsBtn = document.getElementById('clearTrailsBtn');
        const startAudioBtn = document.getElementById('startAudioBtn');
        const downloadAudioBtn = document.getElementById('downloadAudioBtn');
        const downloadHealthBarsBtn = document.getElementById('downloadHealthBarsBtn');
        const startVideoBtn = document.getElementById('startVideoBtn');
        const stopVideoBtn = document.getElementById('stopVideoBtn');
        const downloadVideoBtn = document.getElementById('downloadVideoBtn');
        const recordingStatus = document.getElementById('recordingStatus');
        const redThornColorInput = document.getElementById('redThornColor');
        const blueThornColorInput = document.getElementById('blueThornColor');
        const redHealthColorInput = document.getElementById('redHealthColor');
        const blueHealthColorInput = document.getElementById('blueHealthColor');
        
        const blueSegment1 = document.getElementById('blueSegment1');
        const blueSegment1Picker = document.getElementById('blueSegment1Picker');
        const blueSegment2 = document.getElementById('blueSegment2');
        const blueSegment2Picker = document.getElementById('blueSegment2Picker');
        const blueSegment3 = document.getElementById('blueSegment3');
        const blueSegment3Picker = document.getElementById('blueSegment3Picker');
        const blueSegment4 = document.getElementById('blueSegment4');
        const blueSegment4Picker = document.getElementById('blueSegment4Picker');
        
        const redSegment1 = document.getElementById('redSegment1');
        const redSegment1Picker = document.getElementById('redSegment1Picker');
        const redSegment2 = document.getElementById('redSegment2');
        const redSegment2Picker = document.getElementById('redSegment2Picker');
        const redSegment3 = document.getElementById('redSegment3');
        const redSegment3Picker = document.getElementById('redSegment3Picker');
        const redSegment4 = document.getElementById('redSegment4');
        const redSegment4Picker = document.getElementById('redSegment4Picker');
        
        const standaloneBorderColor = document.getElementById('standaloneBorderColor');
        const standaloneBorderPicker = document.getElementById('standaloneBorderPicker');
        const standaloneEmptyColor = document.getElementById('standaloneEmptyColor');
        const standaloneEmptyPicker = document.getElementById('standaloneEmptyPicker');
        
        let standaloneColors = {
            blueSegments: ['#3498db', '#3498db', '#3498db', '#3498db'],
            redSegments: ['#e74c3c', '#e74c3c', '#e74c3c', '#e74c3c'],
            border: '#333333',
            empty: '#dddddd'
        };
        
        let mediaRecorder = null;
        let recordedChunks = [];
        let isRecording = false;
        
        const backgroundColorText = document.getElementById('backgroundColorText');
        const backgroundColorPicker = document.getElementById('backgroundColorPicker');
        const applyBackgroundBtn = document.getElementById('applyBackgroundBtn');
        const restoreBackgroundBtn = document.getElementById('restoreBackgroundBtn');
        
        const frameColorText = document.getElementById('frameColorText');
        const frameColorPicker = document.getElementById('frameColorPicker');
        const applyFrameBtn = document.getElementById('applyFrameBtn');
        const resetFrameBtn = document.getElementById('resetFrameBtn');
        
        let audioContext = null;
        let audioBuffers = {};
        let audioEvents = [];
        let simulationStartTime = 0;
        let isTrackingAudio = false;
        
        let countdown = 5;
        let countdownActive = false;
        let gameStarted = false;
        
        let isFullscreen = false;
        let originalCanvasSize = { width: 1080, height: 720 };
        let originalCanvasStyle = { width: canvas.style.width, height: canvas.style.height };
        let originalSquarePositions = [];
        let fullscreenScale = 1;
        let fullscreenOffsetX = 0;
        let fullscreenOffsetY = 0;
        
        let frameBounds = {
            left: 20,
            right: canvas.width - 20,
            top: 20,
            bottom: canvas.height - 20
        };
        let frameColor = "#00ff00";
        let frameThickness = 8;
        const MIN_FRAME_SIZE = 100;
        
        const redHealthBar = document.getElementById('redHealthBar');
        const blueHealthBar = document.getElementById('blueHealthBar');
        
        let isPaused = false;
        let speedMultiplier = 1;
        let redThornColor = "#BEBEBE";
        let blueThornColor = "#BEBEBE";
        let redHealthColor = "#e74c3c";
        let blueHealthColor = "#3498db";
        let canvasBackgroundColor = "#ffffff";
        let oldBackgroundColor = canvasBackgroundColor;
        const SOUND_COOLDOWN = 300;
        
        let redSquareHealth = 4;
        let blueSquareHealth = 4;
        let lastRedHealth = -1;
        let lastBlueHealth = -1;
        
        const DEFAULT_SQUARE_SIZE = 120;
        const SPEED = 6;
        
        let loadedImages = 0;
        const totalImages = 6;
        let redImageReady = false;
        let blueImageReady = false;
        let knifeImageReady = false;
        let healImageReady = false;
        let slowImageReady = false;
        let speedImageReady = false;
        
        const redSquareImg = new Image();
        redSquareImg.src = "red.png";
        
        const blueSquareImg = new Image();
        blueSquareImg.src = "blue.png";
        
        const knifeImg = new Image();
        knifeImg.src = "knife.png";
        
        const healImg = new Image();
        healImg.src = "heal.png";
        
        const slowImg = new Image();
        slowImg.src = "slow.png";
        
        const speedImg = new Image();
        speedImg.src = "speed.png";
        
        const RED_SQUARE_COLOR = '#e74c3c';
        const BLUE_SQUARE_COLOR = '#3498db';
        
        const KNIFE_SPAWN_INTERVAL = 8000;
        const HEAL_SPAWN_INTERVAL = 15000;
        const SLOW_SPAWN_INTERVAL = 12000;
        const SPEED_SPAWN_INTERVAL = 10000;
        const THORN_DURATION = 7000;
        const SLOW_DURATION = 5000;
        const SPEED_DURATION = 6000;
        const POWER_UP_SIZE = 60;
        
        let knifeSpawnInterval = null;
        let healSpawnInterval = null;
        let slowSpawnInterval = null;
        let speedSpawnInterval = null;
        
        // Trail variables
        let frameCount = 0;
        const trailParticles = [];
        let activeTrails = 0;

        // Store last trail time for each square
        let lastTrailTimes = {
            blue: 0,
            red: 0
        };

        // Updated TrailParticle class with better size control
        class TrailParticle {
            constructor(x, y, color, useImage = false, image = null) {
                this.x = x;
                this.y = y;
                
                // Use different size ranges based on whether it's a speed trail or normal trail
                const config = useImage ? TRAIL_CONFIG.speed : TRAIL_CONFIG.normal;
                this.size = Math.random() * (config.maxSize - config.minSize) + config.minSize;
                
                this.color = color;
                this.life = 1.0;
                this.decay = Math.random() * 0.02 + 0.01;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.useImage = useImage;
                this.image = image;
                this.rotation = Math.random() * 360;
                this.rotationSpeed = (Math.random() - 0.5) * 8;
                this.sizeDecay = config.sizeDecay;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= this.decay;
                this.size *= this.sizeDecay;
                this.rotation += this.rotationSpeed;
                return this.life > 0 && this.size > 0.1;
            }
            
            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.life;
                
                if (this.useImage && this.image) {
                    // Draw speed.png image for speed trail
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.rotation * Math.PI / 180);
                    ctx.drawImage(this.image, -this.size/2, -this.size/2, this.size, this.size);
                } else {
                    // Draw regular colored circle
                    ctx.fillStyle = this.color;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }

        function createTrail(square) {
            const currentTime = Date.now();
            const squareType = square.isBlue ? 'blue' : 'red';
            
            // Only create trails every TRAIL_SPAWN_RATE milliseconds for each square individually
            if (currentTime - lastTrailTimes[squareType] < TRAIL_SPAWN_RATE) {
                return;
            }
            
            lastTrailTimes[squareType] = currentTime;
            
            // Create trail particles slightly off-center based on movement direction
            const offsetX = (Math.random() - 0.5) * square.size * 0.6;
            const offsetY = (Math.random() - 0.5) * square.size * 0.6;
            
            // Add slight bias in the direction of movement
            const directionBias = 0.3;
            const biasedOffsetX = offsetX + (square.vx > 0 ? directionBias : -directionBias) * square.size * 0.2;
            const biasedOffsetY = offsetY + (square.vy > 0 ? directionBias : -directionBias) * square.size * 0.2;
            
            const trailX = square.x + square.size / 2 + biasedOffsetX;
            const trailY = square.y + square.size / 2 + biasedOffsetY;
            
            // Use the health bar colors for trails
            const trailColor = square.isBlue ? blueHealthColor : redHealthColor;
            
            // Create multiple particles for better trail effect
            for (let i = 0; i < 2; i++) {
                // Add some variation to particle positions
                const particleX = trailX + (Math.random() - 0.5) * square.size * 0.3;
                const particleY = trailY + (Math.random() - 0.5) * square.size * 0.3;
                
                // If square has speed effect, use speed.png images for trails
                const useImage = square.hasSpeed;
                const image = useImage ? speedImg : null;
                
                const particle = new TrailParticle(particleX, particleY, trailColor, useImage, image);
                trailParticles.push(particle);
                activeTrails++;
            }
        }

        function updateTrails() {
            for (let i = trailParticles.length - 1; i >= 0; i--) {
                if (!trailParticles[i].update()) {
                    trailParticles.splice(i, 1);
                    activeTrails--;
                }
            }
        }

        function drawTrails() {
            trailParticles.forEach(particle => {
                particle.draw(ctx);
            });
        }

        function clearTrails() {
            trailParticles.length = 0;
            activeTrails = 0;
            // Reset trail times when clearing
            lastTrailTimes.blue = 0;
            lastTrailTimes.red = 0;
        }

        // Function to restore square to normal speed
        function restoreNormalSpeed(square) {
            const baseSpeed = square.originalSpeed;
            const dirX = Math.sign(square.vx);
            const dirY = Math.sign(square.vy);
            
            square.vx = dirX * baseSpeed;
            square.vy = dirY * baseSpeed;
            square.isSlowed = false;
            square.hasSpeed = false;
        }

        // Function to apply slow effect
        function applySlowEffect(square) {
            // Cancel any speed effect first
            square.hasSpeed = false;
            
            // Apply slow effect
            square.isSlowed = true;
            square.slowExpiryTime = Date.now() + SLOW_DURATION;
            
            // Reduce speed to 75%
            const currentSpeedMultiplier = 0.75;
            
            // Calculate current direction to preserve it
            const speedX = Math.abs(square.vx);
            const speedY = Math.abs(square.vy);
            const dirX = Math.sign(square.vx);
            const dirY = Math.sign(square.vy);
            
            // Apply slow effect
            square.vx = dirX * speedX * currentSpeedMultiplier;
            square.vy = dirY * speedY * currentSpeedMultiplier;
        }

        // Function to apply speed effect
        function applySpeedEffect(square) {
            // Cancel any slow effect first
            square.isSlowed = false;
            
            // Apply speed effect
            square.hasSpeed = true;
            square.speedExpiryTime = Date.now() + SPEED_DURATION;
            
            // Increase speed to 125%
            const currentSpeedMultiplier = 1.25;
            
            // Calculate current direction to preserve it
            const speedX = Math.abs(square.vx);
            const speedY = Math.abs(square.vy);
            const dirX = Math.sign(square.vx);
            const dirY = Math.sign(square.vy);
            
            // Apply speed effect
            square.vx = dirX * speedX * currentSpeedMultiplier;
            square.vy = dirY * speedY * currentSpeedMultiplier;
        }
        
        function setupSegmentColorListeners(textInput, pickerInput, segmentIndex, isBlue) {
            textInput.addEventListener('input', function() {
                if (isValidHexColor(this.value)) {
                    if (isBlue) {
                        standaloneColors.blueSegments[segmentIndex] = this.value;
                    } else {
                        standaloneColors.redSegments[segmentIndex] = this.value;
                    }
                    pickerInput.value = this.value;
                    drawStandaloneHealthBars();
                }
            });
            
            pickerInput.addEventListener('input', function() {
                if (isBlue) {
                    standaloneColors.blueSegments[segmentIndex] = this.value;
                } else {
                    standaloneColors.redSegments[segmentIndex] = this.value;
                }
                textInput.value = this.value;
                drawStandaloneHealthBars();
            });
        }
        
        setupSegmentColorListeners(blueSegment1, blueSegment1Picker, 0, true);
        setupSegmentColorListeners(blueSegment2, blueSegment2Picker, 1, true);
        setupSegmentColorListeners(blueSegment3, blueSegment3Picker, 2, true);
        setupSegmentColorListeners(blueSegment4, blueSegment4Picker, 3, true);
        
        setupSegmentColorListeners(redSegment1, redSegment1Picker, 0, false);
        setupSegmentColorListeners(redSegment2, redSegment2Picker, 1, false);
        setupSegmentColorListeners(redSegment3, redSegment3Picker, 2, false);
        setupSegmentColorListeners(redSegment4, redSegment4Picker, 3, false);
        
        standaloneBorderColor.addEventListener('input', function() {
            if (isValidHexColor(this.value)) {
                standaloneColors.border = this.value;
                standaloneBorderPicker.value = this.value;
                drawStandaloneHealthBars();
            }
        });
        
        standaloneBorderPicker.addEventListener('input', function() {
            standaloneColors.border = this.value;
            standaloneBorderColor.value = this.value;
            drawStandaloneHealthBars();
        });
        
        standaloneEmptyColor.addEventListener('input', function() {
            if (isValidHexColor(this.value)) {
                standaloneColors.empty = this.value;
                standaloneEmptyPicker.value = this.value;
                drawStandaloneHealthBars();
            }
        });
        
        standaloneEmptyPicker.addEventListener('input', function() {
            standaloneColors.empty = this.value;
            standaloneEmptyColor.value = this.value;
            drawStandaloneHealthBars();
        });
        
        function startVideoRecording() {
            try {
                recordedChunks = [];
                const stream = healthBarCanvas.captureStream(60);
                
                mediaRecorder = new MediaRecorder(stream, {
                    mimeType: 'video/webm;codecs=vp9',
                    videoBitsPerSecond: 8000000
                });
                
                mediaRecorder.ondataavailable = function(event) {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };
                
                mediaRecorder.onstop = function() {
                    downloadVideoBtn.disabled = false;
                    recordingStatus.innerHTML = '<span class="recording-indicator">Recording stopped. Click "Download Video" to save.</span>';
                };
                
                mediaRecorder.start();
                isRecording = true;
                
                startVideoBtn.disabled = true;
                stopVideoBtn.disabled = false;
                downloadVideoBtn.disabled = true;
                
                recordingStatus.innerHTML = '<span class="recording-indicator">ðŸ”´ Recording...</span>';
                
                console.log('Video recording started');
            } catch (error) {
                console.error('Failed to start video recording:', error);
                alert('Failed to start video recording. Your browser may not support this feature.');
            }
        }
        
        function stopVideoRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                
                startVideoBtn.disabled = false;
                stopVideoBtn.disabled = true;
                
                console.log('Video recording stopped');
            }
        }
        
        function downloadVideo() {
            if (recordedChunks.length === 0) {
                alert('No video recorded. Start and stop recording first.');
                return;
            }
            
            const blob = new Blob(recordedChunks, { type: 'video/webm' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'health-bars-recording.webm';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            recordingStatus.innerHTML = '';
            downloadVideoBtn.disabled = true;
            
            console.log('Video downloaded');
        }
        
        startVideoBtn.addEventListener('click', startVideoRecording);
        stopVideoBtn.addEventListener('click', stopVideoRecording);
        downloadVideoBtn.addEventListener('click', downloadVideo);
        
        function drawStandaloneHealthBars() {
            // Fill background with #FCFEFE
            healthBarCtx.fillStyle = '#FCFEFE';
            healthBarCtx.fillRect(0, 0, healthBarCanvas.width, healthBarCanvas.height);
            
            const barWidth = 800;
            const barHeight = 100;
            const segmentCount = 4;
            const segmentWidth = barWidth / segmentCount;
            const gap = 200;
            const yPosition = (healthBarCanvas.height - barHeight) / 2;
            const cornerRadius = 25;
            
            const blueX = 100;
            for (let i = 0; i < segmentCount; i++) {
                const x = blueX + (i * segmentWidth);
                
                healthBarCtx.save();
                healthBarCtx.beginPath();
                
                if (i === 0) {
                    healthBarCtx.moveTo(x + cornerRadius, yPosition);
                    healthBarCtx.lineTo(x + segmentWidth, yPosition);
                    healthBarCtx.lineTo(x + segmentWidth, yPosition + barHeight);
                    healthBarCtx.lineTo(x + cornerRadius, yPosition + barHeight);
                    healthBarCtx.arc(x + cornerRadius, yPosition + barHeight - cornerRadius, cornerRadius, Math.PI / 2, Math.PI);
                    healthBarCtx.lineTo(x, yPosition + cornerRadius);
                    healthBarCtx.arc(x + cornerRadius, yPosition + cornerRadius, cornerRadius, Math.PI, Math.PI * 1.5);
                } else if (i === segmentCount - 1) {
                    healthBarCtx.moveTo(x, yPosition);
                    healthBarCtx.lineTo(x + segmentWidth - cornerRadius, yPosition);
                    healthBarCtx.arc(x + segmentWidth - cornerRadius, yPosition + cornerRadius, cornerRadius, Math.PI * 1.5, 0);
                    healthBarCtx.lineTo(x + segmentWidth, yPosition + barHeight - cornerRadius);
                    healthBarCtx.arc(x + segmentWidth - cornerRadius, yPosition + barHeight - cornerRadius, cornerRadius, 0, Math.PI / 2);
                    healthBarCtx.lineTo(x, yPosition + barHeight);
                    healthBarCtx.lineTo(x, yPosition);
                } else {
                    healthBarCtx.rect(x, yPosition, segmentWidth, barHeight);
                }
                
                healthBarCtx.closePath();
                healthBarCtx.clip();
                
                if (i < blueSquareHealth) {
                    healthBarCtx.fillStyle = standaloneColors.blueSegments[i];
                } else {
                    healthBarCtx.fillStyle = standaloneColors.empty;
                }
                healthBarCtx.fillRect(x, yPosition, segmentWidth, barHeight);
                
                healthBarCtx.restore();
                
                healthBarCtx.strokeStyle = standaloneColors.border;
                healthBarCtx.lineWidth = 4;
                healthBarCtx.beginPath();
                
                if (i === 0) {
                    healthBarCtx.moveTo(x + cornerRadius, yPosition);
                    healthBarCtx.lineTo(x + segmentWidth, yPosition);
                    healthBarCtx.lineTo(x + segmentWidth, yPosition + barHeight);
                    healthBarCtx.lineTo(x + cornerRadius, yPosition + barHeight);
                    healthBarCtx.arc(x + cornerRadius, yPosition + barHeight - cornerRadius, cornerRadius, Math.PI / 2, Math.PI);
                    healthBarCtx.lineTo(x, yPosition + cornerRadius);
                    healthBarCtx.arc(x + cornerRadius, yPosition + cornerRadius, cornerRadius, Math.PI, Math.PI * 1.5);
                } else if (i === segmentCount - 1) {
                    healthBarCtx.moveTo(x, yPosition);
                    healthBarCtx.lineTo(x + segmentWidth - cornerRadius, yPosition);
                    healthBarCtx.arc(x + segmentWidth - cornerRadius, yPosition + cornerRadius, cornerRadius, Math.PI * 1.5, 0);
                    healthBarCtx.lineTo(x + segmentWidth, yPosition + barHeight - cornerRadius);
                    healthBarCtx.arc(x + segmentWidth - cornerRadius, yPosition + barHeight - cornerRadius, cornerRadius, 0, Math.PI / 2);
                    healthBarCtx.lineTo(x, yPosition + barHeight);
                    healthBarCtx.lineTo(x, yPosition);
                } else {
                    healthBarCtx.rect(x, yPosition, segmentWidth, barHeight);
                }
                
                healthBarCtx.closePath();
                healthBarCtx.stroke();
            }
            
            const redX = blueX + barWidth + gap;
            for (let i = 0; i < segmentCount; i++) {
                const x = redX + (i * segmentWidth);
                
                healthBarCtx.save();
                healthBarCtx.beginPath();
                
                if (i === 0) {
                    healthBarCtx.moveTo(x + cornerRadius, yPosition);
                    healthBarCtx.lineTo(x + segmentWidth, yPosition);
                    healthBarCtx.lineTo(x + segmentWidth, yPosition + barHeight);
                    healthBarCtx.lineTo(x + cornerRadius, yPosition + barHeight);
                    healthBarCtx.arc(x + cornerRadius, yPosition + barHeight - cornerRadius, cornerRadius, Math.PI / 2, Math.PI);
                    healthBarCtx.lineTo(x, yPosition + cornerRadius);
                    healthBarCtx.arc(x + cornerRadius, yPosition + cornerRadius, cornerRadius, Math.PI, Math.PI * 1.5);
                } else if (i === segmentCount - 1) {
                    healthBarCtx.moveTo(x, yPosition);
                    healthBarCtx.lineTo(x + segmentWidth - cornerRadius, yPosition);
                    healthBarCtx.arc(x + segmentWidth - cornerRadius, yPosition + cornerRadius, cornerRadius, Math.PI * 1.5, 0);
                    healthBarCtx.lineTo(x + segmentWidth, yPosition + barHeight - cornerRadius);
                    healthBarCtx.arc(x + segmentWidth - cornerRadius, yPosition + barHeight - cornerRadius, cornerRadius, 0, Math.PI / 2);
                    healthBarCtx.lineTo(x, yPosition + barHeight);
                    healthBarCtx.lineTo(x, yPosition);
                } else {
                    healthBarCtx.rect(x, yPosition, segmentWidth, barHeight);
                }
                
                healthBarCtx.closePath();
                healthBarCtx.clip();
                
                if (i < redSquareHealth) {
                    healthBarCtx.fillStyle = standaloneColors.redSegments[i];
                } else {
                    healthBarCtx.fillStyle = standaloneColors.empty;
                }
                healthBarCtx.fillRect(x, yPosition, segmentWidth, barHeight);
                
                healthBarCtx.restore();
                
                healthBarCtx.strokeStyle = standaloneColors.border;
                healthBarCtx.lineWidth = 4;
                healthBarCtx.beginPath();
                
                if (i === 0) {
                    healthBarCtx.moveTo(x + cornerRadius, yPosition);
                    healthBarCtx.lineTo(x + segmentWidth, yPosition);
                    healthBarCtx.lineTo(x + segmentWidth, yPosition + barHeight);
                    healthBarCtx.lineTo(x + cornerRadius, yPosition + barHeight);
                    healthBarCtx.arc(x + cornerRadius, yPosition + barHeight - cornerRadius, cornerRadius, Math.PI / 2, Math.PI);
                    healthBarCtx.lineTo(x, yPosition + cornerRadius);
                    healthBarCtx.arc(x + cornerRadius, yPosition + cornerRadius, cornerRadius, Math.PI, Math.PI * 1.5);
                } else if (i === segmentCount - 1) {
                    healthBarCtx.moveTo(x, yPosition);
                    healthBarCtx.lineTo(x + segmentWidth - cornerRadius, yPosition);
                    healthBarCtx.arc(x + segmentWidth - cornerRadius, yPosition + cornerRadius, cornerRadius, Math.PI * 1.5, 0);
                    healthBarCtx.lineTo(x + segmentWidth, yPosition + barHeight - cornerRadius);
                    healthBarCtx.arc(x + segmentWidth - cornerRadius, yPosition + barHeight - cornerRadius, cornerRadius, 0, Math.PI / 2);
                    healthBarCtx.lineTo(x, yPosition + barHeight);
                    healthBarCtx.lineTo(x, yPosition);
                } else {
                    healthBarCtx.rect(x, yPosition, segmentWidth, barHeight);
                }
                
                healthBarCtx.closePath();
                healthBarCtx.stroke();
            }
            
            healthBarCtx.fillStyle = standaloneColors.border;
            healthBarCtx.font = 'bold 24px Arial';
            healthBarCtx.textAlign = 'center';
            healthBarCtx.fillText('Blue Square', blueX + barWidth / 2, yPosition - 20);
            healthBarCtx.fillText('Red Square', redX + barWidth / 2, yPosition - 20);
        }
        
        function downloadHealthBars() {
            healthBarCanvas.toBlob(function(blob) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'health-bars.png';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });
        }
        
        downloadHealthBarsBtn.addEventListener('click', downloadHealthBars);
        
        async function initializeAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                const soundFiles = ['blue.wav', 'red.wav', 'heal.wav', 'knife.wav', 'hit.wav', 'slow.wav', 'speed.wav'];
                
                for (const filename of soundFiles) {
                    try {
                        const response = await fetch(filename);
                        const arrayBuffer = await response.arrayBuffer();
                        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                        const soundName = filename.replace('.wav', '');
                        audioBuffers[soundName] = audioBuffer;
                        console.log(`Loaded ${filename}`);
                    } catch (error) {
                        console.warn(`Failed to load ${filename}:`, error);
                    }
                }
                
                simulationStartTime = Date.now();
                audioEvents = [];
                isTrackingAudio = true;
                return true;
            } catch (error) {
                console.error('Audio initialization failed:', error);
                return false;
            }
        }
        
        function playSound(soundName) {
            if (!isTrackingAudio || !audioBuffers[soundName]) return;
            
            const timestamp = Date.now() - simulationStartTime;
            audioEvents.push({
                sound: soundName,
                time: timestamp / 1000
            });
        }
        
        function playSoundsCombined(soundNames) {
            soundNames.forEach(soundName => {
                if (audioBuffers[soundName]) {
                    playSound(soundName);
                }
            });
        }
        
        function audioBufferToWav(buffer) {
            const length = buffer.length;
            const sampleRate = buffer.sampleRate;
            const arrayBuffer = new ArrayBuffer(44 + length * 2);
            const view = new DataView(arrayBuffer);
            const channelData = buffer.getChannelData(0);
            
            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };
            
            writeString(0, 'RIFF');
            view.setUint32(4, 36 + length * 2, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, 1, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * 2, true);
            view.setUint16(32, 2, true);
            view.setUint16(34, 16, true);
            writeString(36, 'data');
            view.setUint32(40, length * 2, true);
            
            let offset = 44;
            for (let i = 0; i < length; i++) {
                const sample = Math.max(-1, Math.min(1, channelData[i]));
                view.setInt16(offset, sample * 0x7FFF, true);
                offset += 2;
            }
            
            return new Blob([arrayBuffer], { type: 'audio/wav' });
        }
        
        async function downloadAudio() {
            if (audioEvents.length === 0) {
                alert('No audio events recorded. Start audio tracking and play the game first.');
                return;
            }
            
            console.log(`Generating audio from ${audioEvents.length} events`);
            
            const maxTime = Math.max(...audioEvents.map(event => event.time)) + 2;
            const sampleRate = audioContext.sampleRate;
            const totalSamples = Math.ceil(maxTime * sampleRate);
            
            const finalBuffer = audioContext.createBuffer(1, totalSamples, sampleRate);
            const channelData = finalBuffer.getChannelData(0);
            
            for (const event of audioEvents) {
                const soundBuffer = audioBuffers[event.sound];
                if (!soundBuffer) continue;
                
                const startSample = Math.floor(event.time * sampleRate);
                const soundData = soundBuffer.getChannelData(0);
                
                for (let i = 0; i < soundData.length && (startSample + i) < totalSamples; i++) {
                    channelData[startSample + i] += soundData[i] * 0.5;
                }
            }
            
            const wavBlob = audioBufferToWav(finalBuffer);
            const url = URL.createObjectURL(wavBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'game-audio.wav';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            console.log('Audio file generated and download initiated');
        }
        
        function startCountdown() {
            countdownActive = true;
            gameStarted = false;
            countdown = 5;
            isPaused = true;
            
            const countdownInterval = setInterval(() => {
                countdown--;
                
                if (countdown <= 0) {
                    clearInterval(countdownInterval);
                    countdownActive = false;
                    gameStarted = true;
                    isPaused = false;
                    pauseBtn.textContent = 'Pause';
                }
            }, 1000);
        }
        
        function toggleFullscreen() {
            if (!isFullscreen) {
                if (canvas.requestFullscreen) {
                    canvas.requestFullscreen();
                } else if (canvas.webkitRequestFullscreen) {
                    canvas.webkitRequestFullscreen();
                } else if (canvas.mozRequestFullScreen) {
                    canvas.mozRequestFullScreen();
                } else if (canvas.msRequestFullscreen) {
                    canvas.msRequestfullscreen();
                }
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
        }

        function handleFullscreenChange() {
            isFullscreen = !!(document.fullscreenElement || 
                             document.webkitFullscreenElement || 
                             document.mozFullScreenElement || 
                             document.msFullscreenElement);
            
            if (isFullscreen) {
                originalSquarePositions = squares.map(square => ({
                    x: square.x,
                    y: square.y,
                    size: square.size,
                    vx: square.vx,
                    vy: square.vy
                }));
                
                canvas.width = window.screen.width;
                canvas.height = window.screen.height;
                canvas.style.width = '100vw';
                canvas.style.height = '100vh';
                canvas.style.objectFit = 'contain';
                
                const scaleX = canvas.width / originalCanvasSize.width;
                const scaleY = canvas.height / originalCanvasSize.height;
                fullscreenScale = Math.min(scaleX, scaleY);
                
                const newWidth = originalCanvasSize.width * fullscreenScale;
                const newHeight = originalCanvasSize.height * fullscreenScale;
                fullscreenOffsetX = (canvas.width - newWidth) / 2;
                fullscreenOffsetY = (canvas.height - newHeight) / 2;
                
                frameBounds = {
                    left: fullscreenOffsetX + 20 * fullscreenScale,
                    right: fullscreenOffsetX + newWidth - 20 * fullscreenScale,
                    top: fullscreenOffsetY + 20 * fullscreenScale,
                    bottom: fullscreenOffsetY + newHeight - 20 * fullscreenScale
                };
                
                squares.forEach(square => {
                    square.x = (square.x * fullscreenScale) + fullscreenOffsetX;
                    square.y = (square.y * fullscreenScale) + fullscreenOffsetY;
                    square.size = square.size * fullscreenScale;
                    square.vx = square.vx * fullscreenScale;
                    square.vy = square.vy * fullscreenScale;
                });
                
                powerUps.forEach(powerUp => {
                    powerUp.x = (powerUp.x * fullscreenScale) + fullscreenOffsetX;
                    powerUp.y = (powerUp.y * fullscreenScale) + fullscreenOffsetY;
                    powerUp.size = powerUp.size * fullscreenScale;
                });
                
            } else {
                canvas.width = originalCanvasSize.width;
                canvas.height = originalCanvasSize.height;
                canvas.style.width = originalCanvasStyle.width;
                canvas.style.height = originalCanvasStyle.height;
                canvas.style.objectFit = '';
                
                frameBounds = {
                    left: 20,
                    right: canvas.width - 20,
                    top: 20,
                    bottom: canvas.height - 20
                };
                
                if (originalSquarePositions.length > 0) {
                    squares.forEach((square, index) => {
                        if (originalSquarePositions[index]) {
                            square.x = originalSquarePositions[index].x;
                            square.y = originalSquarePositions[index].y;
                            square.size = originalSquarePositions[index].size;
                            square.vx = originalSquarePositions[index].vx;
                            square.vy = originalSquarePositions[index].vy;
                        }
                    });
                }
                
                powerUps = [];
            }
        }

        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
        document.addEventListener('mozfullscreenchange', handleFullscreenChange);
        document.addEventListener('MSFullscreenChange', handleFullscreenChange);
        
        function getRandomPosition(size = POWER_UP_SIZE) {
            const objectSize = size * (isFullscreen ? fullscreenScale : 1);
            return {
                x: frameBounds.left + Math.random() * (frameBounds.right - frameBounds.left - objectSize),
                y: frameBounds.top + Math.random() * (frameBounds.bottom - frameBounds.top - objectSize)
            };
        }
        
        function getRandomSquarePosition() {
            return getRandomPosition(DEFAULT_SQUARE_SIZE);
        }
        
        function spawnKnifePowerUp() {
            if (knifeImageReady) {
                const pos = getRandomPosition(POWER_UP_SIZE);
                powerUps.push({
                    x: pos.x,
                    y: pos.y,
                    size: POWER_UP_SIZE * (isFullscreen ? fullscreenScale : 1),
                    type: 'knife',
                    img: knifeImg
                });
            }
        }
        
        function spawnHealPowerUp() {
            if (healImageReady) {
                const pos = getRandomPosition(POWER_UP_SIZE);
                powerUps.push({
                    x: pos.x,
                    y: pos.y,
                    size: POWER_UP_SIZE * (isFullscreen ? fullscreenScale : 1),
                    type: 'heal',
                    img: healImg
                });
            }
        }
        
        function spawnSlowPowerUp() {
            if (slowImageReady) {
                const pos = getRandomPosition(POWER_UP_SIZE);
                powerUps.push({
                    x: pos.x,
                    y: pos.y,
                    size: POWER_UP_SIZE * (isFullscreen ? fullscreenScale : 1),
                    type: 'slow',
                    img: slowImg
                });
            }
        }
        
        function spawnSpeedPowerUp() {
            if (speedImageReady) {
                const pos = getRandomPosition(POWER_UP_SIZE);
                powerUps.push({
                    x: pos.x,
                    y: pos.y,
                    size: POWER_UP_SIZE * (isFullscreen ? fullscreenScale : 1),
                    type: 'speed',
                    img: speedImg
                });
            }
        }
        
        class Particle {
            constructor(x, y, color = '#4ECDC4') {
                this.x = x;
                this.y = y;
                this.size = Math.random() * 6 + 2;
                this.speedX = (Math.random() - 0.5) * 8;
                this.speedY = (Math.random() - 0.5) * 8;
                this.life = 1;
                this.decay = Math.random() * 0.02 + 0.01;
                this.gravity = 0.1;
                this.bounce = 0.7;
                this.color = color;
            }
            
            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.speedY += this.gravity;
                this.life -= this.decay;
                this.size *= 0.995;
                
                if (this.y + this.size > canvas.height) {
                    this.y = canvas.height - this.size;
                    this.speedY *= -this.bounce;
                    this.speedX *= 0.9;
                }
                
                if (this.x + this.size > canvas.width || this.x - this.size < 0) {
                    this.speedX *= -this.bounce;
                    this.x = Math.max(this.size, Math.min(canvas.width - this.size, this.x));
                }
                
                return this.life > 0 && this.size > 0.1;
            }
            
            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        class ParticleSystem {
            constructor(canvas, options = {}) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.particles = [];
                
                this.options = {
                    color: options.color || '#4ECDC4',
                    particleCount: options.particleCount || 25,
                    autoFade: false,
                    ...options
                };
            }
            
            createExplosion(x, y, count = this.options.particleCount) {
                for (let i = 0; i < count; i++) {
                    const particle = new Particle(x, y, this.options.color);
                    this.particles.push(particle);
                }
            }
            
            update() {
                this.particles = this.particles.filter(particle => particle.update());
            }
            
            draw() {
                this.particles.forEach(particle => particle.draw(this.ctx));
            }
            
            animate() {
                if (this.particles.length > 0) {
                    this.update();
                    this.draw();
                }
            }
            
            clear() {
                this.particles = [];
            }
        }

        const redParticles = new ParticleSystem(canvas, { 
            color: redHealthColor, 
            particleCount: 30
        });
        const blueParticles = new ParticleSystem(canvas, { 
            color: blueHealthColor, 
            particleCount: 30
        });
        
        function createMultiColorExplosion(x, y) {
            const colors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#e67e22', '#1abc9c'];
            
            for (let i = 0; i < 50; i++) {
                const randomColor = colors[Math.floor(Math.random() * colors.length)];
                const particle = new Particle(x, y, randomColor);
                redParticles.particles.push(particle);
                blueParticles.particles.push(particle);
            }
        }
        
        function isValidHexColor(color) {
            return /^#([0-9A-F]{3}|[0-9A-F]{6})$/i.test(color);
        }
        
        function applyBackgroundColor(color) {
            if (isValidHexColor(color)) {
                oldBackgroundColor = canvasBackgroundColor;
                canvasBackgroundColor = color;
                canvas.style.backgroundColor = color;
                backgroundColorText.value = color;
                backgroundColorPicker.value = color;
            } else {
                alert("Invalid hex color format. Use #RRGGBB or #RGB");
            }
        }
        
        function applyFrameColor(color) {
            if (isValidHexColor(color)) {
                frameColor = color;
                frameColorText.value = color;
                frameColorPicker.value = color;
            } else {
                alert("Invalid hex color format. Use #RRGGBB or #RGB");
            }
        }
        
        function resetFrame() {
            if (isFullscreen) {
                frameBounds = {
                    left: fullscreenOffsetX + 20 * fullscreenScale,
                    right: fullscreenOffsetX + (originalCanvasSize.width * fullscreenScale) - 20 * fullscreenScale,
                    top: fullscreenOffsetY + 20 * fullscreenScale,
                    bottom: fullscreenOffsetY + (originalCanvasSize.height * fullscreenScale) - 20 * fullscreenScale
                };
            } else {
                frameBounds = {
                    left: 20,
                    right: canvas.width - 20,
                    top: 20,
                    bottom: canvas.height - 20
                };
            }
        }
        
        function shrinkFrame() {
            const shrinkAmount = 0.5 * (isFullscreen ? fullscreenScale : 1);
            const newLeft = frameBounds.left + shrinkAmount;
            const newRight = frameBounds.right - shrinkAmount;
            const newTop = frameBounds.top + shrinkAmount;
            const newBottom = frameBounds.bottom - shrinkAmount;
            
            const minSize = MIN_FRAME_SIZE * (isFullscreen ? fullscreenScale : 1);
            if (newRight - newLeft >= minSize && newBottom - newTop >= minSize) {
                frameBounds.left = newLeft;
                frameBounds.right = newRight;
                frameBounds.top = newTop;
                frameBounds.bottom = newBottom;
            }
        }
        
        function drawCollisionFrame() {
            ctx.save();
            ctx.shadowColor = frameColor;
            ctx.shadowBlur = 8;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            ctx.strokeStyle = frameColor;
            ctx.lineWidth = frameThickness * (isFullscreen ? fullscreenScale : 1);
            
            ctx.strokeRect(
                frameBounds.left, 
                frameBounds.top, 
                frameBounds.right - frameBounds.left, 
                frameBounds.bottom - frameBounds.top
            );
            
            ctx.shadowBlur = 4;
            ctx.strokeRect(
                frameBounds.left, 
                frameBounds.top, 
                frameBounds.right - frameBounds.left, 
                frameBounds.bottom - frameBounds.top
            );
            
            ctx.restore();
        }
        
        applyBackgroundBtn.addEventListener('click', function() {
            const color = backgroundColorText.value;
            applyBackgroundColor(color);
        });
        
        backgroundColorPicker.addEventListener('input', function() {
            applyBackgroundColor(this.value);
        });
        
        backgroundColorText.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                applyBackgroundColor(this.value);
            }
        });
        
        restoreBackgroundBtn.addEventListener('click', function() {
            applyBackgroundColor(oldBackgroundColor);
        });
        
        applyFrameBtn.addEventListener('click', function() {
            applyFrameColor(frameColorText.value);
        });
        
        frameColorPicker.addEventListener('input', function() {
            applyFrameColor(this.value);
        });
        
        frameColorText.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                applyFrameColor(this.value);
            }
        });
        
        resetFrameBtn.addEventListener('click', resetFrame);
        
        startAudioBtn.addEventListener('click', async function() {
            const success = await initializeAudio();
            if (success) {
                console.log('Audio tracking started');
                startAudioBtn.disabled = true;
                downloadAudioBtn.disabled = false;
                startAudioBtn.textContent = 'Tracking...';
            } else {
                alert('Failed to initialize audio tracking');
            }
        });

        downloadAudioBtn.addEventListener('click', function() {
            downloadAudio();
        });
        
        document.addEventListener('keydown', function(event) {
            const key = event.key.toLowerCase();
            
            switch(key) {
                case 'volumedown':
                    event.preventDefault();
                    pauseBtn.click();
                    break;
                    
                case 'volumeup':
                    event.preventDefault();
                    resetBtn.click();
                    break;
                    
                case '1':
                    event.preventDefault();
                    speedMultiplier = 1;
                    speedBtn.textContent = 'Speed: 1x';
                    break;
                    
                case '2':
                    event.preventDefault();
                    speedMultiplier = 2;
                    speedBtn.textContent = 'Speed: 2x';
                    break;
                    
                case '3':
                    event.preventDefault();
                    speedMultiplier = 3;
                    speedBtn.textContent = 'Speed: 3x';
                    break;
            }
        });
        
        document.addEventListener('keydown', function(event) {
            if (event.key === 'AudioVolumeDown' || event.keyCode === 174) {
                event.preventDefault();
                pauseBtn.click();
            }
            if (event.key === 'AudioVolumeUp' || event.keyCode === 175) {
                event.preventDefault();
                resetBtn.click();
            }
        });
        
        function updateHealthBar(healthBar, health, maxHealth, color) {
            const segments = healthBar.querySelectorAll('.health-segment');
            segments.forEach((segment, index) => {
                if (index < health) {
                    segment.style.backgroundColor = color;
                } else {
                    segment.style.backgroundColor = '#ddd';
                }
            });
        }
        
        function calculateHealth(size) {
            const baseSize = DEFAULT_SQUARE_SIZE * (isFullscreen ? fullscreenScale : 1);
            if (size <= 0) return 0;
            if (size >= baseSize) return 4;
            if (size >= baseSize * 0.75) return 3;
            if (size >= baseSize * 0.5) return 2;
            if (size >= baseSize * 0.25) return 1;
            return 0;
        }
        
        function createSquare(x, y, direction, color, imageSrc, isBlue = false) {
            let vx, vy;
            
            const speed = SPEED * (isFullscreen ? fullscreenScale : 1);
            
            switch(direction) {
                case 0:
                    vx = speed;
                    vy = speed;
                    break;
                case 1:
                    vx = -speed;
                    vy = speed;
                    break;
                case 2:
                    vx = -speed;
                    vy = -speed;
                    break;
                case 3:
                    vx = speed;
                    vy = -speed;
                    break;
            }
            
            const img = isBlue ? blueSquareImg : redSquareImg;
            const size = DEFAULT_SQUARE_SIZE * (isFullscreen ? fullscreenScale : 1);
            
            return {
                x,
                y,
                vx,
                vy,
                size: size,
                direction,
                color,
                img,
                hasThorns: false,
                thornExpiryTime: 0,
                originalSize: size,
                isBlue,
                lastPlayTime: 0,
                isSlowed: false,
                slowExpiryTime: 0,
                originalSpeed: speed,
                hasSpeed: false,
                speedExpiryTime: 0
            };
        }
        
        function initializeSquares() {
            const bluePos= getRandomSquarePosition();
            const redPos = getRandomSquarePosition();

            clearTrails();
            
            let attempts = 0;
            while (Math.abs(bluePos.x - redPos.x) < 200 && Math.abs(bluePos.y - redPos.y) < 200 && attempts < 10) {
                const newRedPos = getRandomSquarePosition();
                redPos.x = newRedPos.x;
                redPos.y = newRedPos.y;
                attempts++;
            }
            
            return [
                createSquare(bluePos.x, bluePos.y, 0, '#3498db', 'blue.png', true),
                createSquare(redPos.x, redPos.y, 2, '#e74c3c', 'red.png', false)
            ];
        }
        
        let squares = initializeSquares();
        let powerUps = [];
        
        function checkPowerUpCollision(square, powerUp) {
            return square.x < powerUp.x + powerUp.size &&
                   square.x + square.size > powerUp.x &&
                   square.y < powerUp.y + powerUp.size &&
                   square.y + square.size > powerUp.y;
        }
        
        function checkCollision(square1, square2) {
            return square1.x < square2.x + square2.size &&
                   square1.x + square1.size > square2.x &&
                   square1.y < square2.y + square2.size &&
                   square1.y + square1.size > square2.y;
        }

        function getCollisionSide(square1, square2) {
            const center1 = { x: square1.x + square1.size / 2, y: square1.y + square1.size / 2 };
            const center2 = { x: square2.x + square2.size / 2, y: square2.y + square2.size / 2 };
            
            const dx = center1.x - center2.x;
            const dy = center1.y - center2.y;
            
            if (Math.abs(dx) > Math.abs(dy)) {
                return dx > 0 ? "right" : "left";
            } else {
                return dy > 0 ? "bottom" : "top";
            }
        }

        function separateSquares(square1, square2) {
            const dx = (square2.x + square2.size/2) - (square1.x + square1.size/2);
            const dy = (square2.y + square2.size/2) - (square1.y + square1.size/2);
            const distance = Math.sqrt(dx*dx + dy*dy);
            
            if (distance < (square1.size + square2.size)/2) {
                const pushDistance = ((square1.size + square2.size)/2 - distance) / 2;
                const pushX = (dx / distance) * pushDistance;
                const pushY = (dy / distance) * pushDistance;
                
                square1.x -= pushX;
                square1.y -= pushY;
                square2.x += pushX;
                square2.y += pushY;
            }
        }

        function handleCollision(square1, square2) {
            const side1 = getCollisionSide(square1, square2);
            const side2 = getCollisionSide(square2, square1);
            
            if (side1 === "left" || side1 === "right") {
                square1.vx *= -1;
                
                if (square1.vy > 0) {
                    square1.direction = square1.vx > 0 ? 0 : 1;
                } else {
                    square1.direction = square1.vx > 0 ? 3 : 2;
                }
            } else {
                square1.vy *= -1;
                
                if (square1.vx > 0) {
                    square1.direction = square1.vy > 0 ? 0 : 3;
                } else {
                    square1.direction = square1.vy > 0 ? 1 : 2;
                }
            }
            
            if (side2 === "left" || side2 === "right") {
                square2.vx *= -1;
                
                if (square2.vy > 0) {
                    square2.direction = square2.vx > 0 ? 0 : 1;
                } else {
                    square2.direction = square2.vx > 0 ? 3 : 2;
                }
            } else {
                square2.vy *= -1;
                
                if (square2.vx > 0) {
                    square2.direction = square2.vy > 0 ? 0 : 3;
                } else {
                    square2.direction = square2.vy > 0 ? 1 : 2;
                }
            }
            
            separateSquares(square1, square2);
            
            const damageAmount = 30 * (isFullscreen ? fullscreenScale : 1);
            const minSize = 30 * (isFullscreen ? fullscreenScale : 1);
            
            if (square1.hasThorns && !square2.hasThorns) {
                const newSize = Math.max(minSize, square2.size - damageAmount);
                
                playSound('hit');
                
                if (square2.size <= minSize) {
                    square2.size = 0;
                    const centerX = square2.x + square2.size / 2;
                    const centerY = square2.y + square2.size / 2;
                    createMultiColorExplosion(centerX, centerY);
                } else {
                    square2.size = newSize;
                    const centerX = square2.x + square2.size / 2;
                    const centerY = square2.y + square2.size / 2;
                    
                    if (square2.isBlue) {
                        blueParticles.createExplosion(centerX, centerY);
                    } else {
                        redParticles.createExplosion(centerX, centerY);
                    }
                }
                
                squares.forEach(sq => sq.hasThorns = false);
            } else if (square2.hasThorns && !square1.hasThorns) {
                const newSize = Math.max(minSize, square1.size - damageAmount);
                
                playSound('hit');
                
                if (square1.size <= minSize) {
                    square1.size = 0;
                    const centerX = square1.x + square1.size / 2;
                    const centerY = square1.y + square1.size / 2;
                    createMultiColorExplosion(centerX, centerY);
                } else {
                    square1.size = newSize;
                    const centerX = square1.x + square1.size / 2;
                    const centerY = square1.y + square1.size / 2;
                    
                    if (square1.isBlue) {
                        blueParticles.createExplosion(centerX, centerY);
                    } else {
                        redParticles.createExplosion(centerX, centerY);
                    }
                }
                
                squares.forEach(sq => sq.hasThorns = false);
            } else {
                playSoundsCombined(['blue', 'red']);
            }
        }
        
        function drawThorns(square) {
            const size = square.size;
            const thornSize = size / 16;
            const thornCount = Math.floor(size / (thornSize * 1.5));
            
            ctx.fillStyle = square.isBlue ? blueThornColor : redThornColor;
            
            for (let i = 0; i < thornCount; i++) {
                const x = square.x + (i * size / thornCount);
                ctx.beginPath();
                ctx.moveTo(x, square.y);
                ctx.lineTo(x + thornSize, square.y - thornSize);
                ctx.lineTo(x + (size / thornCount), square.y);
                ctx.closePath();
                ctx.fill();
            }
            
            for (let i = 0; i < thornCount; i++) {
                const x = square.x + (i * size / thornCount);
                ctx.beginPath();
                ctx.moveTo(x, square.y + size);
                ctx.lineTo(x + thornSize, square.y + size + thornSize);
                ctx.lineTo(x + (size / thornCount), square.y + size);
                ctx.closePath();
                ctx.fill();
            }
            
            for (let i = 0; i < thornCount; i++) {
                const y = square.y + (i * size / thornCount);
                ctx.beginPath();
                ctx.moveTo(square.x, y);
                ctx.lineTo(square.x - thornSize, y + thornSize);
                ctx.lineTo(square.x, y + (size / thornCount));
                ctx.closePath();
                ctx.fill();
            }
            
            for (let i = 0; i < thornCount; i++) {
                const y = square.y + (i * size / thornCount);
                ctx.beginPath();
                ctx.moveTo(square.x + size, y);
                ctx.lineTo(square.x + size + thornSize, y + thornSize);
                ctx.lineTo(square.x + size, y + (size / thornCount));
                ctx.closePath();
                ctx.fill();
            }
        }

        function update() {
            if (isPaused && !countdownActive) return;
            
            const currentTime = Date.now();
            
            // Update trails
            updateTrails();
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (canvasBackgroundColor !== '#ffffff') {
                ctx.fillStyle = canvasBackgroundColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // Add semi-transparent overlay for trail fade effect
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (countdownActive) {
                ctx.save();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#ffffff';
                ctx.font = `${120 * (isFullscreen ? fullscreenScale : 1)}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                if (countdown > 0) {
                    ctx.fillText(countdown.toString(), centerX, centerY);
                } else {
                    ctx.fillText('GO!', centerX, centerY);
                }
                
                ctx.restore();
                return;
            }
            
            drawCollisionFrame();
            
            // Draw trails
            drawTrails();
            
            powerUps.forEach(powerUp => {
                if (powerUp.type === 'knife' && knifeImageReady) {
                    ctx.drawImage(knifeImg, powerUp.x, powerUp.y, powerUp.size, powerUp.size);
                } else if (powerUp.type === 'heal' && healImageReady) {
                    ctx.drawImage(healImg, powerUp.x, powerUp.y, powerUp.size, powerUp.size);
                } else if (powerUp.type === 'slow' && slowImageReady) {
                    ctx.drawImage(slowImg, powerUp.x, powerUp.y, powerUp.size, powerUp.size);
                } else if (powerUp.type === 'speed' && speedImageReady) {
                    ctx.drawImage(speedImg, powerUp.x, powerUp.y, powerUp.size, powerUp.size);
                } else {
                    ctx.fillStyle = powerUp.type === 'knife' ? '#333' : 
                                   powerUp.type === 'heal' ? '#2ecc71' : 
                                   powerUp.type === 'slow' ? '#9b59b6' : '#f39c12';
                    ctx.fillRect(powerUp.x, powerUp.y, powerUp.size, powerUp.size);
                }
            });
            
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const powerUp = powerUps[i];
                
                let powerUpCollected = false;
                for (let j = 0; j < squares.length; j++) {
                    const square = squares[j];
                    
                    if (square.size > 0 && checkPowerUpCollision(square, powerUp)) {
                        if (powerUp.type === 'knife') {
                            squares.forEach(sq => sq.hasThorns = false);
                            
                            square.hasThorns = true;
                            square.thornExpiryTime = currentTime + THORN_DURATION;
                            
                            playSound('knife');
                        } else if (powerUp.type === 'heal') {
                            const healAmount = 30 * (isFullscreen ? fullscreenScale : 1);
                            const maxSize = DEFAULT_SQUARE_SIZE * (isFullscreen ? fullscreenScale : 1);
                            square.size = Math.min(maxSize, square.size + healAmount);
                            
                            playSound('heal');
                        } else if (powerUp.type === 'slow') {
                            // Apply slow effect (this will cancel any speed effect)
                            applySlowEffect(square);
                            playSound('slow');
                        } else if (powerUp.type === 'speed') {
                            // Apply speed effect (this will cancel any slow effect)
                            applySpeedEffect(square);
                            playSound('speed');
                        }
                        
                        powerUpCollected = true;
                        break;
                    }
                }
                
                if (powerUpCollected) {
                    powerUps.splice(i, 1);
                }
            }
            
            for (let i = 0; i < squares.length; i++) {
                const square = squares[i];
                
                if (square.size <= 0) {
                    continue;
                }
                
                // Handle effect expirations
                if (square.hasThorns && currentTime > square.thornExpiryTime) {
                    square.hasThorns = false;
                }
                
                // Handle slow effect expiration
                if (square.isSlowed && currentTime > square.slowExpiryTime) {
                    restoreNormalSpeed(square);
                }
                
                // Handle speed effect expiration
                if (square.hasSpeed && currentTime > square.speedExpiryTime) {
                    restoreNormalSpeed(square);
                }
                
                square.x += square.vx * speedMultiplier;
                square.y += square.vy * speedMultiplier;
                
                // Create trail for moving square
                if (!isPaused && !countdownActive && gameStarted && square.size > 0) {
                    createTrail(square);
                }
                
                if (square.x <= frameBounds.left || square.x + square.size >= frameBounds.right) {
                    square.vx *= -1;
                    shrinkFrame();
                    
                    if (square.isBlue) {
                        playSound('blue');
                    } else {
                        playSound('red');
                    }
                    
                    if (square.direction === 0) square.direction = 1;
                    else if (square.direction === 1) square.direction = 0;
                    else if (square.direction === 2) square.direction = 3;
                    else if (square.direction === 3) square.direction = 2;
                    
                    if (square.x <= frameBounds.left) square.x = frameBounds.left;
                    if (square.x + square.size >= frameBounds.right) square.x = frameBounds.right - square.size;
                }
                
                if (square.y <= frameBounds.top || square.y + square.size >= frameBounds.bottom) {
                    square.vy *= -1;
                    shrinkFrame();
                    
                    if (square.isBlue) {
                        playSound('blue');
                    } else {
                        playSound('red');
                    }
                    
                    if (square.direction === 0) square.direction = 3;
                    else if (square.direction === 1) square.direction = 2;
                    else if (square.direction === 2) square.direction = 1;
                    else if (square.direction === 3) square.direction = 0;
                    
                    if (square.y <= frameBounds.top) square.y = frameBounds.top;
                    if (square.y + square.size >= frameBounds.bottom) square.y = frameBounds.bottom - square.size;
                }
                
                // FIXED: Draw the square image first
                if (square.isBlue && blueImageReady) {
                    ctx.drawImage(blueSquareImg, square.x, square.y, square.size, square.size);
                } else if (!square.isBlue && redImageReady) {
                    ctx.drawImage(redSquareImg, square.x, square.y, square.size, square.size);
                } else {
                    ctx.fillStyle = square.isBlue ? BLUE_SQUARE_COLOR : RED_SQUARE_COLOR;
                    ctx.fillRect(square.x, square.y, square.size, square.size);
                }
                
                // FIXED: Then add 60% grey overlay on top
                if (square.isSlowed) {
                    ctx.fillStyle = 'rgba(128, 128, 128, 0.6)'; // 60% opacity grey
                    ctx.fillRect(square.x, square.y, square.size, square.size);
                }
                
                // Draw border last so it's visible
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2 * (isFullscreen ? fullscreenScale : 1);
                ctx.strokeRect(square.x, square.y, square.size, square.size);
                
                if (square.hasThorns) {
                    drawThorns(square);
                }
            }
            
            const newRedHealth = calculateHealth(squares[1].size);
            const newBlueHealth = calculateHealth(squares[0].size);
            
            if (newRedHealth !== lastRedHealth) {
                updateHealthBar(redHealthBar, newRedHealth, 4, redHealthColor);
                redSquareHealth = newRedHealth;
                drawStandaloneHealthBars();
                lastRedHealth = newRedHealth;
            }
            if (newBlueHealth !== lastBlueHealth) {
                updateHealthBar(blueHealthBar, newBlueHealth, 4, blueHealthColor);
                blueSquareHealth = newBlueHealth;
                drawStandaloneHealthBars();
                lastBlueHealth = newBlueHealth;
            }
            
            if (squares[0].size > 0 && squares[1].size > 0) {
                const dx = Math.abs(squares[0].x - squares[1].x);
                const dy = Math.abs(squares[0].y - squares[1].y);
                const maxDistance = squares[0].size + squares[1].size;
                
                if (dx < maxDistance && dy < maxDistance && checkCollision(squares[0], squares[1])) {
                    handleCollision(squares[0], squares[1]);
                }
            }
            
            redParticles.animate();
            blueParticles.animate();
        }

        function animate() {
            frameCount++;
            update();
            requestAnimationFrame(animate);
        }

        function imageLoaded() {
            loadedImages++;
            if (loadedImages === totalImages) {
                console.log("All images loaded, starting game");
                startGame();
            }
        }

        redSquareImg.onload = () => { 
            redImageReady = true; 
            imageLoaded(); 
        };
        redSquareImg.onerror = () => { 
            console.log("Red square image failed to load");
            imageLoaded(); 
        };
        
        blueSquareImg.onload = () => { 
            blueImageReady = true; 
            imageLoaded(); 
        };
        blueSquareImg.onerror = () => { 
            console.log("Blue square image failed to load");
            imageLoaded(); 
        };
        
        knifeImg.onload = () => { 
            knifeImageReady = true; 
            imageLoaded(); 
        };
        knifeImg.onerror = () => { 
            console.log("Knife image failed to load");
            imageLoaded(); 
        };
        
        healImg.onload = () => { 
            healImageReady = true; 
            imageLoaded(); 
        };
        healImg.onerror = () => { 
            console.log("Heal image failed to load");
            imageLoaded(); 
        };
        
        slowImg.onload = () => { 
            slowImageReady = true; 
            imageLoaded(); 
        };
        slowImg.onerror = () => { 
            console.log("Slow image failed to load");
            imageLoaded(); 
        };
        
        speedImg.onload = () => { 
            speedImageReady = true; 
            imageLoaded(); 
        };
        speedImg.onerror = () => { 
            console.log("Speed image failed to load");
            imageLoaded(); 
        };

        setTimeout(() => {
            if (loadedImages < totalImages) {
                console.log("Some images failed to load, starting anyway");
                startGame();
            }
        }, 3000);

        function startGame() {
            animate();
            startCountdown();
            drawStandaloneHealthBars();
            knifeSpawnInterval = setInterval(spawnKnifePowerUp, KNIFE_SPAWN_INTERVAL);
            healSpawnInterval = setInterval(spawnHealPowerUp, HEAL_SPAWN_INTERVAL);
            slowSpawnInterval = setInterval(spawnSlowPowerUp, SLOW_SPAWN_INTERVAL);
            speedSpawnInterval = setInterval(spawnSpeedPowerUp, SPEED_SPAWN_INTERVAL);
        }

        updateHealthBar(redHealthBar, redSquareHealth, 4, redHealthColor);
        updateHealthBar(blueHealthBar, blueSquareHealth, 4, blueHealthColor);
        
        resetBtn.addEventListener('click', function() {
            if (knifeSpawnInterval) clearInterval(knifeSpawnInterval);
            if (healSpawnInterval) clearInterval(healSpawnInterval);
            if (slowSpawnInterval) clearInterval(slowSpawnInterval);
            if (speedSpawnInterval) clearInterval(speedSpawnInterval);
            
            squares = initializeSquares();
            powerUps = [];
            speedMultiplier = 1;
            speedBtn.textContent = 'Speed: 1x';
            
            redSquareHealth = 4;
            blueSquareHealth = 4;
            lastRedHealth = -1;
            lastBlueHealth = -1;
            
            resetFrame();
            
            redParticles.clear();
            blueParticles.clear();
            clearTrails();
            
            if (isTrackingAudio) {
                simulationStartTime = Date.now();
                audioEvents = [];
            }
            
            startCountdown();
            drawStandaloneHealthBars();
            
            knifeSpawnInterval = setInterval(spawnKnifePowerUp, KNIFE_SPAWN_INTERVAL);
            healSpawnInterval = setInterval(spawnHealPowerUp, HEAL_SPAWN_INTERVAL);
            slowSpawnInterval = setInterval(spawnSlowPowerUp, SLOW_SPAWN_INTERVAL);
            speedSpawnInterval = setInterval(spawnSpeedPowerUp, SPEED_SPAWN_INTERVAL);
        });

        pauseBtn.addEventListener('click', function() {
            isPaused = !isPaused;
            pauseBtn.textContent = isPaused ? 'Resume' : 'Pause';
        });

        speedBtn.addEventListener('click', function() {
            speedMultiplier = (speedMultiplier >= 3) ? 1 : speedMultiplier + 0.5;
            this.textContent = `Speed: ${speedMultiplier}x`;
        });

        fullscreenBtn.addEventListener('click', function() {
            toggleFullscreen();
        });

        clearTrailsBtn.addEventListener('click', function() {
            clearTrails();
        });
        
        redThornColorInput.addEventListener('input', function() {
            if (isValidHexColor(this.value)) {
                redThornColor = this.value;
            }
        });
        
        blueThornColorInput.addEventListener('input', function() {
            if (isValidHexColor(this.value)) {
                blueThornColor = this.value;
            }
        });
        
        redHealthColorInput.addEventListener('input', function() {
            if (isValidHexColor(this.value)) {
                redHealthColor = this.value;
                redParticles.options.color = this.value;
            }
        });
        
        blueHealthColorInput.addEventListener('input', function() {
            if (isValidHexColor(this.value)) {
                blueHealthColor = this.value;
                blueParticles.options.color = this.value;
            }
        });
    </script>
</body>
</html>
